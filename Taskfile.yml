version: "3"

tasks:
  # Code Quality Tasks
  fmt:
    desc: Format Lua code with StyLua
    cmds:
      - stylua --check src/
      - echo "‚úÖ Code formatting is correct"
    silent: false

  fmt-fix:
    desc: Auto-fix Lua code formatting with StyLua
    cmds:
      - stylua src/
      - echo "‚úÖ Code formatted successfully"

  lint:
    desc: Run luacheck static analysis
    cmds:
      - luacheck src/
      - echo "‚úÖ No linting issues found"

  lsp-check:
    desc: Run lua-language-server diagnostics on entire workspace (like Neovim does)
    cmds:
      - lua-language-server --check=. --checklevel=Warning --configpath=.luarc.json
      - echo "‚úÖ No LSP diagnostics found"

  check:
    desc: Run all code quality checks (format + lint + lsp)
    deps:
      - fmt
      - lint
      - lsp-check
    cmds:
      - echo "‚úÖ All code quality checks passed"

  pre-commit:
    desc: Run quality checks only on staged/changed files (for pre-commit hooks)
    cmds:
      - task: pre-commit-fmt
      - task: pre-commit-lint
      - echo "‚úÖ Pre-commit checks passed"

  pre-commit-fmt:
    desc: Check formatting only on staged files
    cmds:
      - |
        STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.lua$' || true)
        if [ -n "$STAGED_FILES" ]; then
          echo "üìù Checking formatting for staged files..."
          echo "$STAGED_FILES" | xargs stylua --check
          echo "‚úÖ Staged files formatting is correct"
        else
          echo "‚ÑπÔ∏è  No staged Lua files to check"
        fi

  pre-commit-lint:
    desc: Run luacheck only on staged files
    cmds:
      - |
        STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.lua$' || true)
        if [ -n "$STAGED_FILES" ]; then
          echo "üîç Linting staged files..."
          echo "$STAGED_FILES" | xargs luacheck
          echo "‚úÖ Staged files passed linting"
        else
          echo "‚ÑπÔ∏è  No staged Lua files to lint"
        fi

  pre-commit-lsp:
    desc: Run LSP check (always checks entire workspace)
    cmds:
      - |
        STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.lua$' || true)
        if [ -n "$STAGED_FILES" ]; then
          echo "‚ö†Ô∏è  Skipping LSP diagnostics in pre-commit (checks entire workspace)"
          echo "   Run 'task lsp' manually to check with language server"
        else
          echo "‚ÑπÔ∏è  No staged Lua files, skipping LSP check"
        fi

  fix:
    desc: Auto-fix all fixable issues
    deps:
      - fmt-fix
    cmds:
      - echo "‚úÖ Auto-fixes applied"
  build:
    desc: Build release artifact
    cmds:
      - task: clean
      - task: copy-files
      - task: verify

  build-optimized:
    desc: Build optimized release artifact (removes comments)
    cmds:
      - task: clean
      - task: copy-files
      - task: remove-comments
      - task: verify

  remove-comments:
    desc: Remove comments from dist files to reduce size
    cmds:
      - lua scripts/remove-comments.lua dist/miniflux.koplugin
      - echo "‚úÖ Comments removed from dist files"

  clean:
    desc: Clean build directory
    cmds:
      - rm -rf dist
      - mkdir -p dist

  copy-files:
    desc: Copy all files from src/ to build directory
    cmds:
      - mkdir -p dist/miniflux.koplugin
      - cp -r src/* dist/miniflux.koplugin/

  verify:
    desc: Verify release artifact contents
    cmds:
      - echo "=== Release artifact contents ==="
      - find dist -type f | sort

  # Release Task
  release:
    desc: "Create a release (usage: task release version=patch|minor|major [dry_run=true])"
    silent: true
    cmds:
      - task: _release-validate
        vars:
          version: "{{.version}}"
          dry_run: "{{.dry_run}}"
      - |
        if [ "{{.dry_run}}" != "true" ]; then
          echo "üîÑ Running quality checks..."
        fi
      - |
        if [ "{{.dry_run}}" != "true" ]; then
          task check
        fi
      - task: _release-execute
        vars:
          version: "{{.version}}"
          dry_run: "{{.dry_run}}"

  _release-validate:
    internal: true
    silent: true
    cmds:
      - |
        # Validate required parameters
        if [ -z "{{.version}}" ]; then
          echo "‚ùå Missing required parameter: version"
          echo ""
          echo "Usage:"
          echo "  task release version=patch      # 0.1.0 ‚Üí 0.1.1"
          echo "  task release version=minor      # 0.1.0 ‚Üí 0.2.0"
          echo "  task release version=major      # 0.1.0 ‚Üí 1.0.0"
          echo "  task release version=1.5.3      # 0.1.0 ‚Üí 1.5.3 (explicit)"
          echo ""
          echo "Options:"
          echo "  dry_run=true                    # Preview without executing"
          echo ""
          echo "Examples:"
          echo "  task release version=patch"
          echo "  task release version=minor dry_run=true"
          exit 1
        fi
        
        # Check if version is semantic (patch/minor/major) or explicit (x.y.z)
        if [[ "{{.version}}" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          # Explicit version provided
          EXPLICIT_VERSION="{{.version}}"
          VERSION_TYPE="explicit"
        else
          # Validate semantic version parameter
          case "{{.version}}" in
            patch|minor|major)
              VERSION_TYPE="semantic"
              ;;
            *)
              echo "‚ùå Invalid version parameter: {{.version}}"
              echo "Valid options: patch, minor, major, or explicit version (e.g., 1.2.3)"
              exit 1
              ;;
          esac
        fi
        
        # Get current version from _meta.lua
        CURRENT=$(grep -o "version = '[^']*'" src/_meta.lua | sed "s/version = '\(.*\)'/\1/")
        echo "üìç Current version: $CURRENT"
        
        # Calculate new version
        if [ "$VERSION_TYPE" = "explicit" ]; then
          NEW_VERSION="$EXPLICIT_VERSION"
        else
          # Parse version parts for semantic bumping
          IFS='.' read -r major minor patch <<< "$CURRENT"
          
          # Calculate new version based on bump type
          case "{{.version}}" in
            major)
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              ;;
            patch)
              patch=$((patch + 1))
              ;;
          esac
          
          NEW_VERSION="$major.$minor.$patch"
        fi
        
        # Show what will happen
        echo ""
        echo "üöÄ {{.version}} release: $CURRENT ‚Üí $NEW_VERSION"
        echo ""
        # Get current branch for display
        CURRENT_BRANCH=$(git branch --show-current)
        echo "This will:"
        echo "  ‚Ä¢ Run all quality checks (lint, format, LSP)"
        echo "  ‚Ä¢ Update src/_meta.lua version to $NEW_VERSION"
        echo "  ‚Ä¢ Create commit: 'chore: bump version to $NEW_VERSION'"
        echo "  ‚Ä¢ Create and push tag: v$NEW_VERSION"
        echo "  ‚Ä¢ Push to current branch: $CURRENT_BRANCH"
        echo "  ‚Ä¢ Trigger GitHub Actions automated release"
        echo ""
        
        # Handle dry run
        if [ "{{.dry_run}}" = "true" ]; then
          echo "üîç DRY RUN - No changes will be made"
          echo ""
          echo "To execute for real: task release version={{.version}}"
          exit 0
        fi
        
        # Confirmation prompt
        printf "Are you sure you want to create this release? [y/N]: "
        read -r confirm
        case "$confirm" in
          [yY]|[yY][eE][sS])
            echo "‚úÖ Proceeding with release..."
            ;;
          *)
            echo "‚ùå Release cancelled"
            exit 1
            ;;
        esac

  _release-execute:
    internal: true
    silent: true
    cmds:
      - |
        if [ "{{.dry_run}}" = "true" ]; then
          exit 0
        fi
        
        # Calculate new version (same logic as validation)
        if [[ "{{.version}}" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          NEW_VERSION="{{.version}}"
        else
          # Get current version and bump semantically
          CURRENT=$(grep -o "version = '[^']*'" src/_meta.lua | sed "s/version = '\(.*\)'/\1/")
          IFS='.' read -r major minor patch <<< "$CURRENT"
          
          case "{{.version}}" in
            major)
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              ;;
            patch)
              patch=$((patch + 1))
              ;;
          esac
          
          NEW_VERSION="$major.$minor.$patch"
        fi
        
        # Update _meta.lua
        echo "üìù Updating src/_meta.lua to $NEW_VERSION..."
        sed -i.bak "s/version = '[^']*'/version = '$NEW_VERSION'/" src/_meta.lua
        rm -f src/_meta.lua.bak
        
        # Commit and tag
        echo "üìù Creating commit..."
        git add src/_meta.lua
        git commit -m "chore: bump version to $NEW_VERSION"
        
        echo "üè∑Ô∏è  Creating and pushing tag v$NEW_VERSION..."
        git tag "v$NEW_VERSION"
        
        # Push to current branch instead of hardcoding main
        CURRENT_BRANCH=$(git branch --show-current)
        echo "üì§ Pushing to branch: $CURRENT_BRANCH"
        git push origin "$CURRENT_BRANCH"
        git push origin "v$NEW_VERSION"
        
        echo ""
        echo "‚úÖ Release v$NEW_VERSION created successfully!"
        echo "üì§ Pushed to branch: $CURRENT_BRANCH"
        echo "üöÄ GitHub Actions will create the release automatically"
        echo "üîó Check: https://github.com/$(git config --get remote.origin.url | sed 's/.*github.com[:/]\([^.]*\).*/\1/')/actions"

  release-undo:
    desc: "Undo the last release (before pushing to remote)"
    silent: true
    cmds:
      - |
        echo "üîç Checking for unpushed release commits..."
        
        # Check if there are any unpushed commits
        UNPUSHED=$(git log origin/main..HEAD --oneline | grep "chore: bump version to" | head -1)
        if [ -z "$UNPUSHED" ]; then
          echo "‚ùå No unpushed version bump commits found"
          echo "This command only works if you haven't pushed the release yet"
          exit 1
        fi
        
        # Extract version from the commit message
        VERSION=$(echo "$UNPUSHED" | sed 's/.*chore: bump version to \([0-9.]*\).*/\1/')
        TAG="v$VERSION"
        
        echo "üìç Found unpushed release: $TAG"
        echo "Commit: $UNPUSHED"
        echo ""
        echo "This will:"
        echo "  ‚Ä¢ Delete local tag: $TAG"
        echo "  ‚Ä¢ Reset commit: Remove version bump commit"
        echo "  ‚Ä¢ Restore _meta.lua to previous version"
        echo ""
        printf "Are you sure you want to undo this release? [y/N]: "
        read -r confirm
        case "$confirm" in
          [yY]|[yY][eE][sS])
            echo "‚úÖ Undoing release..."
            ;;
          *)
            echo "‚ùå Undo cancelled"
            exit 1
            ;;
        esac
        
        # Delete the local tag if it exists
        if git tag | grep -q "^$TAG$"; then
          echo "üè∑Ô∏è  Deleting local tag: $TAG"
          git tag -d "$TAG"
        fi
        
        # Reset the last commit (the version bump)
        echo "‚è™ Resetting version bump commit"
        git reset --hard HEAD~1
        
        echo ""
        echo "‚úÖ Release $TAG has been undone!"
        echo "üìù Your _meta.lua has been restored to the previous version"
        echo "üí° You can now make corrections and create a new release"

